// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: account.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccount = `-- name: CreateAccount :one
INSERT INTO account (key_id, short_id, region, promo, discount)
VALUES ($1, $2, $3, $4, $5) RETURNING id
`

type CreateAccountParams struct {
	KeyID    string
	ShortID  string
	Region   string
	Promo    pgtype.Text
	Discount pgtype.Int4
}

func (q *Queries) CreateAccount(ctx context.Context, arg CreateAccountParams) (int32, error) {
	row := q.db.QueryRow(ctx, createAccount,
		arg.KeyID,
		arg.ShortID,
		arg.Region,
		arg.Promo,
		arg.Discount,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createPlatformAccount = `-- name: CreatePlatformAccount :exec
INSERT INTO platform_account (platform_id, external_account_id, fk_account_id)
VALUES ($1, $2, $3)
`

type CreatePlatformAccountParams struct {
	PlatformID        int16
	ExternalAccountID int64
	FkAccountID       int32
}

func (q *Queries) CreatePlatformAccount(ctx context.Context, arg CreatePlatformAccountParams) error {
	_, err := q.db.Exec(ctx, createPlatformAccount, arg.PlatformID, arg.ExternalAccountID, arg.FkAccountID)
	return err
}

const findUsersForServiceCheck = `-- name: FindUsersForServiceCheck :many
SELECT
    a.id,
    pa.external_account_id,
    a.language
FROM account AS a
INNER JOIN platform_account AS pa ON a.id = pa.fk_account_id
WHERE
    a.created_at <= NOW() - INTERVAL '5 minutes'
    AND a.service_check_sent = 0
`

type FindUsersForServiceCheckRow struct {
	ID                int32
	ExternalAccountID int64
	Language          string
}

func (q *Queries) FindUsersForServiceCheck(ctx context.Context) ([]FindUsersForServiceCheckRow, error) {
	rows, err := q.db.Query(ctx, findUsersForServiceCheck)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUsersForServiceCheckRow
	for rows.Next() {
		var i FindUsersForServiceCheckRow
		if err := rows.Scan(&i.ID, &i.ExternalAccountID, &i.Language); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccountByID = `-- name: GetAccountByID :one
SELECT
    id,
    cluster_id,
    key_id,
    short_id,
    tariff,
    discount,
    promo,
    freemium_status,
    subscription_status,
    subscription_expires_at,
    devices,
    used_uplink,
    used_downlink,
    protocol,
    region,
    language,
    currency,
    last_key_refresh_at,
    last_traffic_refresh_at
FROM account
WHERE id = $1
`

type GetAccountByIDRow struct {
	ID                    int32
	ClusterID             pgtype.Int2
	KeyID                 string
	ShortID               string
	Tariff                int16
	Discount              pgtype.Int4
	Promo                 pgtype.Text
	FreemiumStatus        AccessStatus
	SubscriptionStatus    AccessStatus
	SubscriptionExpiresAt pgtype.Timestamptz
	Devices               pgtype.Int2
	UsedUplink            int64
	UsedDownlink          int64
	Protocol              string
	Region                string
	Language              string
	Currency              string
	LastKeyRefreshAt      pgtype.Timestamptz
	LastTrafficRefreshAt  pgtype.Timestamptz
}

func (q *Queries) GetAccountByID(ctx context.Context, id int32) (GetAccountByIDRow, error) {
	row := q.db.QueryRow(ctx, getAccountByID, id)
	var i GetAccountByIDRow
	err := row.Scan(
		&i.ID,
		&i.ClusterID,
		&i.KeyID,
		&i.ShortID,
		&i.Tariff,
		&i.Discount,
		&i.Promo,
		&i.FreemiumStatus,
		&i.SubscriptionStatus,
		&i.SubscriptionExpiresAt,
		&i.Devices,
		&i.UsedUplink,
		&i.UsedDownlink,
		&i.Protocol,
		&i.Region,
		&i.Language,
		&i.Currency,
		&i.LastKeyRefreshAt,
		&i.LastTrafficRefreshAt,
	)
	return i, err
}

const getAccountByKeyID = `-- name: GetAccountByKeyID :one
SELECT
    id,
    cluster_id,
    key_id,
    short_id,
    tariff,
    discount,
    promo,
    freemium_status,
    subscription_status,
    subscription_expires_at,
    devices,
    used_uplink,
    used_downlink,
    protocol,
    region,
    language,
    currency,
    last_key_refresh_at,
    last_traffic_refresh_at
FROM account
WHERE key_id = $1
`

type GetAccountByKeyIDRow struct {
	ID                    int32
	ClusterID             pgtype.Int2
	KeyID                 string
	ShortID               string
	Tariff                int16
	Discount              pgtype.Int4
	Promo                 pgtype.Text
	FreemiumStatus        AccessStatus
	SubscriptionStatus    AccessStatus
	SubscriptionExpiresAt pgtype.Timestamptz
	Devices               pgtype.Int2
	UsedUplink            int64
	UsedDownlink          int64
	Protocol              string
	Region                string
	Language              string
	Currency              string
	LastKeyRefreshAt      pgtype.Timestamptz
	LastTrafficRefreshAt  pgtype.Timestamptz
}

func (q *Queries) GetAccountByKeyID(ctx context.Context, keyID string) (GetAccountByKeyIDRow, error) {
	row := q.db.QueryRow(ctx, getAccountByKeyID, keyID)
	var i GetAccountByKeyIDRow
	err := row.Scan(
		&i.ID,
		&i.ClusterID,
		&i.KeyID,
		&i.ShortID,
		&i.Tariff,
		&i.Discount,
		&i.Promo,
		&i.FreemiumStatus,
		&i.SubscriptionStatus,
		&i.SubscriptionExpiresAt,
		&i.Devices,
		&i.UsedUplink,
		&i.UsedDownlink,
		&i.Protocol,
		&i.Region,
		&i.Language,
		&i.Currency,
		&i.LastKeyRefreshAt,
		&i.LastTrafficRefreshAt,
	)
	return i, err
}

const getAccountIDByPlatform = `-- name: GetAccountIDByPlatform :one
SELECT fk_account_id
FROM platform_account
WHERE
    platform_id = $1
    AND external_account_id = $2
`

type GetAccountIDByPlatformParams struct {
	PlatformID        int16
	ExternalAccountID int64
}

func (q *Queries) GetAccountIDByPlatform(ctx context.Context, arg GetAccountIDByPlatformParams) (int32, error) {
	row := q.db.QueryRow(ctx, getAccountIDByPlatform, arg.PlatformID, arg.ExternalAccountID)
	var fk_account_id int32
	err := row.Scan(&fk_account_id)
	return fk_account_id, err
}

const getAllAccountsByPlatform = `-- name: GetAllAccountsByPlatform :many
SELECT external_account_id
FROM platform_account
WHERE platform_id = $1
`

func (q *Queries) GetAllAccountsByPlatform(ctx context.Context, platformID int16) ([]int64, error) {
	rows, err := q.db.Query(ctx, getAllAccountsByPlatform, platformID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var external_account_id int64
		if err := rows.Scan(&external_account_id); err != nil {
			return nil, err
		}
		items = append(items, external_account_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformUserID = `-- name: GetPlatformUserID :one
SELECT external_account_id
FROM platform_account
WHERE fk_account_id = $1
`

func (q *Queries) GetPlatformUserID(ctx context.Context, fkAccountID int32) (int64, error) {
	row := q.db.QueryRow(ctx, getPlatformUserID, fkAccountID)
	var external_account_id int64
	err := row.Scan(&external_account_id)
	return external_account_id, err
}

const markServiceCheckSent = `-- name: MarkServiceCheckSent :exec
UPDATE account SET service_check_sent = 1
WHERE id = $1
`

func (q *Queries) MarkServiceCheckSent(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, markServiceCheckSent, id)
	return err
}

const setTariff = `-- name: SetTariff :exec
UPDATE account SET tariff = $1
WHERE id = $2
`

type SetTariffParams struct {
	Tariff int16
	ID     int32
}

func (q *Queries) SetTariff(ctx context.Context, arg SetTariffParams) error {
	_, err := q.db.Exec(ctx, setTariff, arg.Tariff, arg.ID)
	return err
}
